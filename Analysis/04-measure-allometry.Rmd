---
title: "04-measure-allometry"
author: "Ariel Marcy"
date: "2019-01-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../allometry-rodents')
```

# Allometry
Changing size is one of the most common ways that organisms can change their shape. Modifications to growth during development often have a profound impact on adult shape. The tests in this script detect how much size appears to drive shape change in our sample.

This script generates Figure 1 and data for Table 1a. 

It also produces supplementary Figures TK 

### Load packages, functions, and data
```{r message = FALSE}
# Install latest `geomorph`
library("devtools")
devtools::install_github("geomorphR/geomorph", ref = "Stable", build_vignettes = TRUE) 

library(geomorph)
library(RRPP)  # needed for pairwise comparisons with new `geomorph`
source("../Functions/utilities.R")  # loads custom functions
load(file = "../Data/Processed/03-main-data.rda")
load(file = "../Data/Processed/03-tree-data.rda")
load(file = "../Data/Processed/03-graphing-vectors.rda")
```

## 1a) Measure static allometry: Homogeneity of Slopes Test by species
Isolate only those species with at least 8 specimens. This leaves our dataset with 31 species.
```{r}
spec.counts <- as.data.frame(table(info$Taxa))
to.remove <- spec.counts[which(spec.counts$Freq <= 7), ]
species.rm <- as.vector(to.remove$Var1)

# For loop to take out these specimens
dataset.rm <- NULL  # initiate blank data frame
for(n in 1:dim(to.remove)[1]) {
        dataset.rm <- c(dataset.rm, which(info$Taxa == species.rm[n]))
}

# Remove species from:
info.HOS <- info[c(-dataset.rm), ]  # Metadata
shape.HOS <- shape[, , c(-sort(dataset.rm))]  # Shape dataset
```

Run allometry tests as well as a homogeneity of slopes test. This test may take 1-2 min to run. Updated for `geomorph` 3.1.0. 
```{r}
# HOS test defined as a function for conciseness in the next block. Returns pairwise object from RRPP
TestHOS <- function(shape, size, group, iter = 500, lm.fun) {
        # Data frame
        spp.gdf <- geomorph.data.frame(coords = shape, size = size, spp = group)
        # Models
        fit.unique <- lm.fun(coords ~ log(size) * spp, iter = iter, data = spp.gdf, RRPP = FALSE, print.progress = FALSE)  # unique allometries by spp
        fit.common <- lm.fun(coords ~ log(size) + spp, iter = iter, data = spp.gdf, RRPP = FALSE, print.progress = FALSE)  # common allometries across spp
        anova(fit.common, fit.unique, print.progress = FALSE)

        return(pairwise(fit.common, fit.unique, groups = spp.gdf$spp, print.progress = FALSE))  # includes Homogeneity of Slope pairwise comparisons
}

# Run with HOS dataset sampled above
pw.comp <- TestHOS(shape.HOS, info.HOS$Csize, info.HOS$Taxa, lm.fun = procD.lm)  

#pw.comp <- TestHOS(shape, info$Csize, info$Taxa, lm.fun = procD.lm) 

# Count number of significant pairwise comparisons of alloemtric slope
pw.summary <- summary.pairwise(pw.comp, test.type = "VC", angle.type = "deg", confidence = 0.95, show.vectors = TRUE)  
actual.pw <- length(which(pw.summary$pairwise.tables$P < 0.05))

# Export p-value matrix to Results folder
write.csv(pw.summary$pairwise.tables$P, "../Data/Results/TableS4_HOS.csv")
```

## Do same analysis but using RRPP's function lm.rrpp
```{r}
spp.rdf <- rrpp.data.frame(coords = two.d.array(shape.HOS), size = info.HOS$Csize, spp = info.HOS$Taxa)

#spp.rdf <- rrpp.data.frame(coords = two.d.array(shape), size = info$Csize, spp = info$Taxa)

# Models
fit.unique.2 <- lm.rrpp(coords ~ log(size) * spp, iter = 500, data = spp.rdf, RRPP = TRUE, print.progress = FALSE)  # unique allometries by spp
fit.common.2 <- lm.rrpp(coords ~ log(size) + spp, iter = 500, data = spp.rdf, RRPP = TRUE, print.progress = FALSE)  # common allometries across spp

pw.comp.2 <- pairwise(fit.common.2, fit.unique.2, groups = spp.rdf$spp, print.progress = FALSE)

pw.summary.2 <- summary.pairwise(pw.comp.2, test.type = "VC", angle.type = "deg", confidence = 0.95, show.vectors = TRUE)  
actual.pw.2 <- length(which(pw.summary.2$pairwise.tables$P < 0.05))

```


## 1b) Randomize specimens to get NULL expantancy for pairwise significant results
We'll do the randomization procedure 100 times. This takes at least 20 minutes to run.
```{r}
# Define function to shuffle species attributions and run PW comparisons; this randomizes species relative to centroid size
null.pairwise <- function(shape, info, iter = 500, confidence = 0.95) {
        rand.spp <- sample(info$Taxa)
        
        # Run the test with random sample
        pw.comp <- TestHOS(shape, info$Csize, rand.spp, lm.fun = procD.lm)
        pw.summary <- summary.pairwise(pw.comp, test.type = "VC", angle.type = "deg", confidence = confidence, show.vectors = TRUE)
        
        # Count number of significant pairwise comparisons of allometric slope
        alpha <- 1 - confidence
        return(length(which(pw.summary$pairwise.tables$P < alpha)))
}

# Do this 100 times
count.pw <- 1
for(i in 1:100){
        null.pw <- null.pairwise(shape = shape.HOS, info.HOS, iter = 500)
        count.pw <- c(count.pw, null.pw)
        print(i)
}

# Visualize with histogram
hist(count.pw[2:length(count.pw)])  # and remove initializing 1
abline(v = actual.pw, lwd = 3)  # compare random to real result above
```

## 1c) Visualize Static Allometry: Predicted Value
In _geomorph_, static allometry can be visualized with log(centroid size) plotted versus the projected regression score of shape ~ size, a common way of quantifying "size-less" shape.
```{r}
# Run static allometry test with all specimens
static.gdf <- geomorph.data.frame(coords = shape, size = info$Csize, spp = info$Taxa)
fit.static <- procD.lm(coords ~ log(size) * spp, iter = 500, data = static.gdf, print.progress = FALSE)

# See ANOVA
fit.static$call
fit.static$aov.table

# Save these values for plotting
static.allo.rs <- plotAllometry(fit.static, size = static.gdf$size, method = "RegScore")
static.allo.pl <- plotAllometry(fit.static, size = static.gdf$size, method = "PredLine")

# Find the mean point for each static allometry
mean.size <- aggregate(static.allo.rs$size.var, list(Taxa = info$Taxa), mean)
mean.shape <- aggregate(static.allo.rs$RegScore, list(Taxa = info$Taxa), mean)
```

### Plot/export static and evolutionary allometry multipanel Figure TK
Here we consolidate the information above into two static allometry plots, one with all the data points and one with just the regression lines for each species to compare with the evolutionary allometry of the entire group. 
```{r}
setEPS()  # sets up plot export
postscript("../Data/Results/Figure2_Static_Evo_Allo.eps")
layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE))

# Plot of all data points with evolutionary allometry
par(mar = c(1, 4, 1.5, 0))
plot(fit.static,
     type = "regression",
     reg.type = "RegScore",
     predictor = log(static.gdf$size),
     xlim = c(4.7, 6.4),
     col = sp.col.gen, 
     pch = pch.spp,
     bg = sp.col.gen,
     main = "Static and evolutionary allometry",
     xlab = NA,
     ylab = "Shape (Regression Score)",
     bty = "n")
#text(4.7, 0.05, "a", cex = 2)
abline(lm(mean.shape$V1 ~ log(mean.size$x)), col = "dark grey", lwd = 2)  # plots evolutionary allometry
text(5.5, -0.04, paste("Rsq of log(size) = ", round(fit.static$aov.table$Rsq[1], 2)), cex = 1.1, col = "black")

# Species Legend
legend(6.05, 0.06, legend = phylo.names, col = col.unique.spp, border = NULL, pch = pch.unique.spp, pt.bg = col.unique.spp, cex = 0.97, pt.cex = 1, ncol = 2, bg = "white")

# Plot of static allometry with evolutionary allometry
par(mar = c(5, 4, 1.5, 0))
plot(fit.static,
     type = "regression",
     reg.type = "PredLine",
     predictor = log(static.gdf$size),
     xlim = c(4.7, 6.4),
     col = sp.col.gen, 
     pch = pch.spp,
     bg = sp.col.gen,
     xlab = "Log(centroid size)",
     ylab = "Shape (Predicted Value)",
     bty = "n")
#text(4.7, 0.05, "b", cex = 2)
text(5.6, -0.08, paste("Rsq of log(size):species = ", round(fit.static$aov.table$Rsq[3], 2)), cex = 1.1, col = "black")

dev.off()
```

## 2) Measure Evolutionary Allometry, reported in Table 1
Here we run Procrustes ANOVAs to compare the relative impact of PHYLO CLADE (Aplin 2014), size, and their interaction on shape.
```{r}
# Remove clades with only one species (Mus and Pogonomys)
one.spp <- c(which(info.means$Clade == "Mus"), which(info.means$Clade == "Pogonomys"))  # index for removal
e.info.means <- info.means[-one.spp, ]  # metadata
e.mean.shapes <- mean.shapes[, , -one.spp]  # shape data
e.aus.tree <- drop.tip(aus.tree, c("Mus_musculus", "Pogonomys_mollipilosis"))  # phylo tree

# Procrustes ANOVA with interaction
evo.allo.clade.gdf <- geomorph.data.frame(Shape = e.mean.shapes, size = e.info.means$MeanCsize, Clade = factor(e.info.means$Clade))

evo.allo.clade <- procD.lm(Shape ~log(size) * Clade, iter = 500, data = evo.allo.clade.gdf)
evo.allo.clade$call
evo.allo.clade$aov.table
```

### Do pairwise comparisons to see which phylo groups are significantly different
```{r}
pairwise.clade <- pairwise(evo.allo.clade, groups = evo.allo.clade.gdf$Clade)
summary(pairwise.clade, confidence = 0.95, test.type = "VC", angle.type = "deg")  # correlation between mean vectors (angles in degrees)
```

## Try evolutionary allometry with individuals instead:
```{r}
# Run static allometry test with all specimens
evo.gdf <- geomorph.data.frame(coords = shape, size = info$Csize, clade = info$Clade)
fit.evo <- procD.lm(coords ~ log(size) * clade, iter = 500, data = evo.gdf, print.progress = FALSE)

# See ANOVA
fit.evo$call
fit.evo$aov.table

pw.ind.clade <- pairwise(fit.evo, groups = evo.gdf$clade)
summary(pw.ind.clade, confidence = 0.95, test.type = "VC", angle.type = "deg")  # correlation between mean vectors (angles in degrees)
```

##### NEEDS UPDATING
### Export Tables 1a,b as CSV files
```{r}
# Round all values to 3 decimals and remove NAs from the tables
table1a <- as.data.frame(round(spp.results$aov.table, 3))
table1a[is.na(table1a)] <- ""

table1b <- as.data.frame(round(evo.allo.gen$aov.table, 3))
table1b[is.na(table1b)] <- ""

# Export
write.table(table1a, "../Data/Results/Table1a_species_ANOVA.csv", sep = ",", col.names = NA)
write.table(table1b, "../Data/Results/Table1b_genus_ANOVA.csv", sep = ",", col.names = NA)
```

### Save intermediate data ADD EVO ALLOMETRY HERE********
```{r}
save(fit.static, static.allo.pl, static.allo.rs, file = "../Data/Processed/04-allometry-data.rda")
```


## 3) Perform rarefaction along the tree
This addresses reviewer concerns over small sample sizes in each species bin and whether it underlies some or all of our results showing parallel slopes across almost all species. The code below is based on Dr Thomas Guillerme's [landvR vignette here](https://github.com/TGuillerme/landvR/blob/master/inst/vignettes/rarefy_regressions.Rmd)

### Getting each clade
First we need to identify and isolate each element from each partition (clade) using a modified version from the `ape::prop.part` function.
```{r}
# Create simple data table with label, centroid size, and RegProj
short.label <- function(label) paste0(substr(strsplit(label, split = "_")[[1]][1], 1, 1), "_", substr(strsplit(label, split = "_")[[1]][2], 1, 3))
aus.tree.stlbl <- aus.tree
aus.tree.stlbl$tip.label <- unname(sapply(aus.tree.stlbl$tip.label, short.label))

rare.table <- data.frame(info$Taxa, log(info$Csize), unname(static.allo.rs$RegScore))
colnames(rare.table) <- c("Taxa", "Csize", "RegProj")
rownames(rare.table) <- NULL

# Getting the tree partitions (with singletons) with function defined in landvR and modified from ape
clades <- prop.part.names(aus.tree.stlbl, singletons = TRUE)

# Make function for getting the dataset for each clade
get.data.clade <- function(clade, data, species.col.n, data.cols) {
    return(data[which(data[, species.col.n] %in% clade), data.cols])
}

# Use function to get all the datasets per clades
data.clades <- lapply(clades, get.data.clade, data = rare.table,
                      species.col.n = 1, data.cols = c(2:3))  # 2:3 corresponds to Csize and RegProj in rare.table
```

### Applying the tests
We can then calculate the delta slope (observed - rarefied slope) by using the lowest potential number of specimens in our dataset (5 - see above).
```{r}
# First define function for getting the slope of a linear model
GetSlope <- function(data) {
    return(lm(data)$coefficients[[2]])  # gives m, slope from y = mx + error
}

# Get the rarefied statistics for each clade with rarefy.stat, another new function in landvR
delta.slopes <- lapply(data.clades, rarefy.stat, stat.fun = GetSlope, rarefaction = 5)  # 5 = the lowest n of specimens for a species in our dataset
```

### Summarising the results
We can then summarise these results per clade size (that's already done in this example) and adding the clade names (if they exist):
```{r}
# Clean up axis labels for plotting
new.names <- unlist(lapply(clades, paste, collapse = "+"))
for(i in 1:length(new.names))
    if(nchar(new.names[i]) > 5) {  # detect bins of greater than 1 spp
        new.names[i] <- ((nchar(new.names[i]) + 1) / 6)  # gets number of spp
    }

# Some vanity names for plotting
new.names[1] <- "All 36"
new.names[2] <- "No Mus 35"
new.names[3] <- "AOE 27"
new.names[which(new.names == 11)] <- "Pse. 11"
new.names[which(new.names == 8)] <- "Rat. 8"
new.names[25] <- "Not. 4"
```

### Plot CI format
```{r}
# An empty plot first
boxplot(delta.slopes, border = "white", ylim = quantile(unlist(delta.slopes), probs = c(0.01, 0.99), na.rm = TRUE), ylab = "Delta slope", xlab = "Clade", names = new.names, las = 2)

plot.CI(delta.slopes, type = "polygon", CI = c(95, 50), cent.tend = median, point.col = "black")
```

## Test for "significant" delta slopes
```{r}
test.delta.slope <- function(slope, significance) {
    angle <- abs(atan(slope) * 180/pi)  # converts slope change into degrees
    if(!missing(significance)) {
        return(ifelse(angle < significance, TRUE, FALSE))
    } else {
        return(angle)
    }
}

med.delta.slopes <- unlist(lapply(delta.slopes, median))
med.delta.slopes[which(is.na(med.delta.slopes))] <- 0  # account for NAs

is.parallel <- test.delta.slope(med.delta.slopes, significance = 45)
sum(is.parallel)

plot(c(1:length(med.delta.slopes)), abs(atan(med.delta.slopes)) * 180/pi, xlab = "Clade", ylab = "Delta slope angle (deg)", pch = 16)

# run on median values of real clade data delta slopes
# FALSE = failed the signifance / delta slope is above 5 degree difference
# 4.5 ideal cut-off because 90*0.5 = 4.5, therefore has 5% chance of being off so good null; 9 degrees is not horrible (10 degrees)
```

## Checking the validity of the results above by randomizing species into "fake clades"
First create some fake clade groupings (i.e. non phylogenetic) and connect it to real data by individuals
```{r}
# Getting the same number of "groups" per "clades"
clades <- prop.part.names(aus.tree, singletons = FALSE)
n.spp.group <- sort(unlist(lapply(clades, length)), decreasing = TRUE)  # sort by big->small for graphing at the end

# Make function to get rarefied statistics for a fake clade grouping
RareFlakes <- function(n.spp.group, rare.table) {
        # Spp names for each fake clade as per n in each clade
        fake.clades <- lapply(n.spp.group, function(n.spp.group, names = rare.table$Taxa) sample(names, n.spp.group))
        
        # Use get.data.clade function from above to grab datasets for clades
        data.flakes <- lapply(fake.clades, get.data.clade, data = rare.table, species.col.n = 1, data.cols = c(2:3))
        
        # Get the rarefied statistics for each clade
        delta.slopes <- lapply(data.flakes, rarefy.stat, stat.fun = GetSlope, rarefaction = 5)
        
        return(delta.slopes)
}
```

### Applying the tests to the "fake clades" (called data.flakes) x 100
Again, calculate the delta slope (observed - rarefied slope) by using the lowest potential number of specimens in our dataset (5 - see above).
```{r}
delta.slopes <- list()
for(i in 1:100) {  # Rep 100 times
        delta.slopes[[i]] <- do.call(cbind, RareFlakes(n.spp.group, rare.table))
}
fake.results.table <- do.call(rbind, delta.slopes)  # full matrix of slope values
colnames(fake.results.table) <- n.spp.group
```

### Summarising the results
We can then summarise these results per clade size (that's already done in this example) and adding the clade names (if they exist):
```{r}
# Adding the names to the slopes
names(delta.slopes) <- n.spp.group
names(delta.slopes.overall) <- n.spp.group
```

And then transform these statistics into tables to simply plot them with `boxplot`:
```{r, fig.width = 12, fig.height = 12}
# An empty plot first
fake.results.list <- apply(fake.results.table, 2, list)
colnames(fake.results.table) <- n.spp.group
plot(NULL, xlim = c(0, length(fake.results.list)), ylim = quantile(unlist(fake.results.table), probs = c(0.01, 0.99), na.rm = T))

boxplot(fake.results.table, border = "white", ylim = quantile(unlist(fake.results.table), probs = c(0.01, 0.99), na.rm = T), ylab = "Delta slope", xlab = "Number of species")

# Adding the results
plot.CI(unlist(fake.results.list, recursive = FALSE), type = "polygon", CI = c(50, 95), cent.tend = median, point.col = "black")
```


##### Recycling bin
### Old boxplot format for real clade data
And then transform these statistics into tables to simply plot them with `boxplot`:
```{r, fig.width = 12, fig.height = 12}
boxplot(do.call(cbind, delta.slopes),
        ylab = expression(paste(Delta, "slope")), xlab = "Clade",
        main = "Slope difference for each clade", las = 2)
abline(h = 0, lty = 3)
```

### We can also compare them to the slope of the the full dataset:
```{r}
# Getting the rarefied statistics for each clade
delta.slopes.overall <- lapply(data.flakes, rarefy.stat, stat.fun = GetSlope, rarefaction = 5, observed = GetSlope(rare.table[, c(2, 3)]))

names(delta.slopes.overall) <- unlist(lapply(clades, paste, collapse = "+"))

boxplot(do.call(cbind, delta.slopes.overall),
        ylab = expression(paste(Delta, "slope")), xlab = "Clade",
        main = "Slope difference for each clade (compared to the whole dataset)", las = 2)
abline(h = 0, lty = 3)  # since observered minus expected should be 0
```
