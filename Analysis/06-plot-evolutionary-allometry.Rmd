---
title: "06-plot-evolutionary-allometry"
authors: "Ariel Marcy & Thomas Guillerme"
date: "2/14/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../allometry-rodents')
```

# Phylogenetic analyses
Here we plot the Principal Components Analysis as a phylomorphospace to visualize morphological variation in context with the phylogeny. PC1 is highly correlated allometric shape. 

We also plot evolutionary allometry to visualize species which diverge.

This script generates Figure 3. 

### Load packages, functions, and data from previous steps
```{r message = FALSE}
library(stringr)
library(ape)  # needed to work with phylogenies
library(geiger)  # needed to work with phylogenies
library(phytools)  # needed to work with phylogenies
library(data.table)
library(geomorph)
library(plotrix)  # needed to draw ellipses
library(landvR)  # needed for rarefaction along the tree; must be v >= 0.4
load(file = "../Data/Processed/02-main-data.rda")
load(file = "../Data/Processed/03-color-data.rda")
load(file = "../Data/Processed/04-phylo-data.rda")
source("../Functions/utilities.R")  # custom functions
source("../Functions/plotGMPhyloMorphoSpace_plotmod.R")  # modified geomorph function
source("../Functions/phytools.branch.colors.R")  # modified phytools function
```

## Make multipanel Figure 3: evolutionary allometry and mean shape PCA/phylomorphosapce
First, set up colors and points by genera and important taxa
```{r}
# Make an Effective Genus column to categorize Mastacomys phylogenetically within Pseudomys
info.means.tree$EGenus <- info.means.tree$Genus
info.means.tree$EGenus[which(info.means.tree$Genus == "Mas")] <- "Pse"

# Colors for genera and different points by species within each genus; used for PCA
col.means <- PlotByGroup(info.means.tree, "EGenus", col.gen)  # standard colors from script 03 minus genus Conilurus
pch.means <- PointOutDiffSpp(info.means.tree)  # pts by unique species in a genus
pch.means[which(info.means.tree$Taxa == "M_fus")] <- 2  # open triangle

# Points to call out only specialized folivores with special characters; used for Evolutionary Allometry plot
pch.evo.allo <- rep(16, length(col.means))  # other taxa are circles
pch.evo.allo[which(info.means.tree$Taxa == "P_ora")] <- 11  # star
pch.evo.allo[which(info.means.tree$Taxa == "M_fus")] <- 2  # open triangle
```

### Run PCA
```{r}
pca.means <- plotTangentSpace(mean.shapes.tree)  # PCA of mean shapes

# Write x and y labels with proportion of variance for PC1 and PC2
PCs <- pca.means$pc.summary$importance
PC1.per <- round(PCs[2, 1] * 100, digits = 1)  # % with 1 decimal
PC1.lab <- paste("PC", 1, " (", PC1.per, "%)", sep = "")
PC2.per <- round(PCs[2, 2] * 100, digits = 1)
PC2.lab <- paste("PC", 2, " (", PC2.per, "%)", sep = "")
```

### Generate data for Evolutionary Allometry plot
```{r}
# Run allometry on all 34 species
evo.procD <- geomorph.data.frame(shape = mean.shapes.tree, size = info.means.tree$MeanCsize, genus = info.means.tree$Genus)
mean.allo <- procD.allometry(shape ~ log(size), data = evo.procD)
```

### Isolate molecular rates used for phylogeny in paper and color-code branches by rates
```{r}
annotations <- aus.tree$node.comment

# Use function to strip rates from annotated NEXUS file
StripAnnotation <- function(input, annotation) {
        strsplit(strsplit(input, split = annotation)[[1]][2], split = ",")[[1]][1]
}
rates <- as.character(lapply(as.list(annotations), StripAnnotation, annotation = ",rate="))

aus.rates <- as.numeric(rates[which(!is.element(relabel.tree$tip.label, concord$tree_not_data))])
names(aus.rates) <- aus.tree$tip.label

# Plot molecular rate of evolution, light branch = slower; dark =faster
gray.branches <- phytools.branch.colors(aus.tree, aus.rates, gray)
gray.branches.10 <- darken(gray.branches, 0.1)  # make white branches visible
```

## Plot and export the multi-panel Figure 3
Evolutionary allometry plot on top, PCA in the middle, two heatmaps on the bottom

ERROR: memory issues when trying to add legend within setEPS. Works when lines 107-177 are run through the console, plot is "zoomed" from RStudio, and then screenshot from that window
```{r}
# Find Notomys' color
Not.col <- col.gen[which(names(col.gen) == "Not")]

# Read in heatmap PNGs created with script 05
dor <- readPNG("../Data/Processed/PC1heatmap_dor.png")
lat <- readPNG("../Data/Processed/PC1heatmap_lat.png")

setEPS()  # sets up plot export
postscript("../Data/Results/Figure3_EvoAllo_PCA_Heatmaps.eps")
mat <- matrix(c(1,1,2,2,3,4), 3, 2, byrow = TRUE)  # 3 rows, 2 columns
layout(mat, widths = c(1, 1, 1), heights = c(0.65, 0.75, 0.5))  

# 1) Evolutionary Allometry plot
par(mar = c(4, 4, 1, 1))  # sets the margins
plot(x = log(info.means.tree$MeanCsize),
     y = mean.allo$Reg.proj,
     xlim = c(4.75, 6),
     col = col.means, 
     pch = pch.evo.allo,
     xlab = "Log centroid size", 
     ylab = "Shape",
     bty = "n")
text(4.75, 0.1, "a", cex = 2)

legend(x = "bottomright", legend = genera.phylo, col = col.phylo, pch = 16, cex = 0.85, pt.cex = 0.85, ncol = 4, bty = "n")

abline(lm(mean.allo$Reg.proj ~ log(info.means.tree$MeanCsize)), col = "dark grey", lwd = 1)  # plots evolutionary allometry line of best fit

text(5.77, 0.11, "Frugivores", col = "dark grey")
draw.ellipse(5.92, .115, .08, .005, angle = 1, border = "dark grey")

text(5.35, 0.08, "Folivores", col = "dark grey")
draw.ellipse(5.41, .047, .11, .02, angle = 5, border = "dark grey")

text(5.8, 0.066, "Carnivore", col = "dark grey")
text(5.05, 0.015, "Carnivore", col = "dark grey")

text(5.3, -0.055, "Hopping Notomys", col = Not.col)
draw.ellipse(5.12, -0.055, .075, .012, angle = 8, border = "dark grey")

# 2) PCA
par(mar=c(4, 4, 1, 1))  # sets the margins
PCAlims = c(-0.08, 0.12)
plot(x = -pca.means$pc.scores[, 1],
     y = pca.means$pc.scores[, 2],
     xlim = PCAlims,
     ylim = PCAlims,
     col = col.means,
     pch = pch.means,
     bg = col.means,
     xlab = PC1.lab, 
     ylab = PC2.lab,
     bty = "n")
text(-0.08, 0.1, "b", cex = 2)
text(.105, -0.009, "Frugivores", col = "dark grey")
draw.ellipse(.116, .015, .006, .012, angle = -12, border = "dark grey")
text(.045, 0.065, "Folivores", col = "dark grey")
draw.ellipse(.048, .035, .025, .013, angle = -19, border = "dark grey")
text(.045, -0.053, "Carnivores", col = "dark grey")
draw.ellipse(.044, -.073, .034, .007, angle = -15, border = "dark grey")
text(-.067, 0.034, "Notomys", col = Not.col)
draw.ellipse(c(-.053, -0.07), c(.014, -0.013), c(.015, .004), c(.004, .007), angle = c(-95, 0), border = c("dark grey", "dark grey"))  # draws both

# 3) Plot dorsal view
par(mar = c(0, 0, 1, 0))
plot(c(0, dim(dor)[2]), c(0, dim(dor)[1]), type = "n", axes = F, xlab = "", ylab = "", asp = T) 
rasterImage(dor, 0, 0, dim(dor)[2], dim(dor)[1])
text(0, dim(dor)[1]-10, "c", cex = 2)

# 4) Plot lateral view with same dimensions as above
par(mar = c(0, 0, 1, 0))
plot(c(0, dim(dor)[2]), c(0, dim(dor)[1]), type = "n", axes = F, xlab = "", ylab = "", asp = T)
rasterImage(lat, 0, 0, dim(dor)[2], dim(dor)[1])
text(0, dim(dor)[1]-10, "d", cex = 2)

# Make gradient legend
legend_image <- as.raster(matrix(heat.colors(20), ncol = 1))
rasterImage(legend_image, 440, 220, 465, 160)
text(382, 213, "High variation", col = "dark grey", cex = 1)
text(414, 168, "Low", col = "dark grey", cex = 1)

dev.off()
```

### Plot phylomorphospace for supplementary materials
Uses modified `geomorph` function `plotGMPhyloMorphoSpace_plotmod` which can be found in the Functions folder of this repository.
```{r}
gray.branches.10 <- rep("dark gray", length(gray.branches.10)) # needed handle decision to no longer color the branches

setEPS()
postscript("../Data/Results/FigureS3_PhyloPCA.eps")

plotGMPhyloMorphoSpace_plotmod(aus.tree, mean.shapes.tree, xaxis = -1, tip.labels = F, node.labels = F, plot.param = list(t.bg = col.means, t.pch = pch.means, t.cex = 1.5, n.cex = .75, l.col = gray.branches.10, lwd = 2, main = "PCA Phylomorphospace", xlab = PC1.lab, ylab = PC2.lab, xlim = PCAlims, ylim = PCAlims))

dev.off()  # finishes plot export
```

## Perform rarefaction along the tree
This addresses reviewer concerns over small sample sizes in each species bin and whether it underlies some or all of our results showing parallel slopes across almost all species. 

The code below is based on Dr Thomas Guillerme's [landvR vignette here](https://github.com/TGuillerme/landvR/blob/master/inst/vignettes/rarefy_regressions.Rmd)

### Getting each clade
First we need to identify and isolate each element from each partition (clade) using a modified version from the `ape::prop.part` function.
```{r}
# Prep a simple data table with names, centroid sizes, and PC scores
rare.table <- data.frame(info.means.tree$FullName, info.means.tree$MeanCsize, -pca.means$pc.scores[, 1], pca.means$pc.scores[, 2])
colnames(rare.table) <- c("FullName", "MeanCsize", "PC1", "PC2")
rownames(rare.table) <- NULL

# Modify a function from ape to ID and isolate each element from each clade
prop.part.names <- function(phy, singletons = FALSE) {
    ## Sanitizing
    if(class(phy) != "phylo") {
        stop("phy must be a \"phylo\" object.")
    }
    if(class(singletons) != "logical") {
        stop("singletons must be logical.")
    }

    # Get the bipartitions
    clades <- ape::prop.part(phy)

    # Get the tips names for each clades
    clades <- lapply(clades, function(clade, labels) labels[clade], labels = attr(clades, "labels"))

    # Add the tip names
    if(singletons) {
        clades <- c(clades, as.list(phy$tip.label))
    }

    return(clades)
}

# Getting the tree partitions (with singletons)
clades <- prop.part.names(aus.tree, singletons = TRUE)

# Make function for getting the dataset for each clade
get.data.clade <- function(clade, data, species.col.n, data.cols) {
    return(data[which(data[ ,species.col.n] %in% clade), data.cols])
}

# Use function to get all the datasets per clades
data_clades <- lapply(clades, get.data.clade, data = rare.table,
                      species.col.n = 1, data.cols = c(2:4))
```

### Applying the tests
First we need to define the function that will get us the statistic. In our case we want the slope from a linear model (but any statistic can be used):

```{r}
# Function for getting the slope of a linear model
my_function <- function(data) {
    return(lm(data)$coefficients[[2]])
}
```

We can then calculate the delta slope (observed - rarefied slope) by using the lowest potential number of specimens in our dataset (5 - see above).
```{r}
# Define function for rarification or bootstrap
rarefy.stat <- function(data, stat.fun, rarefaction, replicates = 100, observed, ...) {
    # Sanitizing
    #check.class(data, c("matrix", "data.frame"))
    nrow_data <- nrow(data)
    #check.class(stat.fun, "function")
    if(!is.null(rarefaction)) {
        #check.class(rarefaction, c("numeric", "integer"))
        # Check if rarefaction is bigger than the # of rows in the data set
        if(rarefaction > nrow_data) {
            warning(paste0("Rarefaction value (", rarefaction, ") is bigger than the number of rows in the data (", nrow_data, ").\nThe statistic will be only bootstrapped."))
            # Set rarefaction as the number of rows in the data (bootstrap)
            rarefaction <- nrow_data    
        }
    } else {
        # Set rarefaction as the number of rows in the data (bootstrap)
        rarefaction <- nrow(data)
    }
    #check.class(replicates, c("numeric", "integer"))
    
    # Check the observed value
    if(!missing(observed)) {
        #check.class(observed, c("numeric", "integer"))
    } else {
        observed <- stat.fun(data)
    }

    # Rarefaction function
    results <- replicate(replicates, stat.fun(data[sample(1:nrow_data, rarefaction, replace = TRUE), ]))

    # Getting the differences
    return(results - observed)
}

# Getting the rarefied statistics for each clade
delta_slopes <- lapply(data_clades, rarefy.stat, stat.fun = my_function, rarefaction = 5)
```

We can also compare them to the slope of the the full dataset:
```{r}
# Getting the rarefied statistics for each clade
delta_slopes_overall <- lapply(data_clades, rarefy.stat, stat.fun = my_function, rarefaction = 5, observed = my_function(rare.table[, c(2, 4)]))
```

### Summarising the results
We can then summarise these results per clade size (that's already done in this example) and adding the clade names (if they exist):

```{r}
# Adding the names to the slopes
names(delta_slopes) <- unlist(lapply(clades, paste, collapse = "+"))
names(delta_slopes_overall) <- unlist(lapply(clades, paste, collapse = "+"))
```

And then transform these statistics into tables to simply plot them with `boxplot`:

```{r, fig.width = 12, fig.height = 12}
par(mfrow = c(2, 1))
# Combining the results into tables and plotting them
boxplot(do.call(cbind, delta_slopes),
        ylab = expression(paste(Delta, "slope")), xlab = "Clade",
        main = "Slope difference for each clade", las = 2)
abline(h = 0, lty = 3)
boxplot(do.call(cbind, delta_slopes_overall),
        ylab = expression(paste(Delta, "slope")), xlab = "Clade",
        main = "Slope difference for each clade (compared to the whole dataset)", las = 2)
abline(h = my_function(rare.table[, c(2, 4)]), lty = 3)
```